<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DVDS Availability</title>
  <style>
    :root{--bg:#0b1320;--panel:#111827;--ink:#e5e7eb;--muted:#94a3b8;--brand:#34b16a;--edge:#263042}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.45 system-ui,Segoe UI,Roboto}
    .wrap{max-width:1100px;margin:48px auto;padding:0 20px;display:flex;flex-direction:column;gap:32px}
    .card{background:var(--panel);border-radius:18px;box-shadow:0 10px 24px rgba(0,0,0,.35);padding:24px}
    h1{margin:0 0 16px;font-size:26px}
    h2{margin:0 0 16px;font-size:22px}
    p{margin:0 0 12px;color:var(--muted)}
    label{display:block;margin:10px 0 6px;color:var(--muted)}
    input,select,button{width:100%;padding:12px 14px;border-radius:12px;border:1px solid var(--edge);background:#0f172a;color:var(--ink)}
    button{background:var(--brand);border:none;color:#052814;font-weight:700;cursor:pointer;transition:background .2s ease}
    button:hover{background:#2d995a}
    .grid{display:grid;gap:12px;grid-template-columns:repeat(3,1fr)}
    .grid2{display:grid;gap:12px;grid-template-columns:repeat(2,1fr)}
    .full{grid-column:1 / -1}
    @media (max-width:880px){.grid{grid-template-columns:1fr}.grid2{grid-template-columns:1fr}}
    .row{display:flex;gap:12px;flex-wrap:wrap;margin:12px 0}
    .row button{flex:1 1 220px}
    .slots{display:grid;gap:10px;grid-template-columns:repeat(auto-fill,minmax(190px,1fr));margin-top:16px}
    .slot{background:#0a1222;border:1px solid var(--edge);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:6px}
    .slot b{font-size:15px}
    .small{font-size:13px;color:var(--muted)}
    pre{background:#0a1222;border-radius:12px;padding:14px;white-space:pre-wrap;word-break:break-word;margin-top:16px}
    .badge{display:inline-block;padding:3px 8px;border-radius:999px;background:#0a1222;border:1px solid var(--edge);font-size:12px;color:var(--muted);cursor:pointer}
    .notice{background:#0a1222;border:1px solid var(--edge);border-radius:12px;padding:12px}
    .pool-times{display:grid;gap:8px;margin-top:12px}
    .pool-entry{display:flex;align-items:center;justify-content:space-between;gap:12px;background:#091120;border:1px solid var(--edge);border-radius:12px;padding:10px 12px}
    .pool-entry button{width:auto;min-width:120px;padding:10px 18px}
    .pool-info b{display:block;font-size:15px}
    .pool-info .small{margin-top:4px}
    .pool-info .sources{font-size:12px;color:var(--muted);margin-top:2px}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>DVDS Availability (Production)</h1>
    <p>Choose account, calendar, date, and appointment type. Then fetch live slots.</p>
    <div class="grid">
      <div>
        <label>Account</label>
        <select id="account">
          <option value="main">Main</option>
          <option value="parents">Parents</option>
        </select>
      </div>
      <div>
        <label>Location</label>
        <select id="locationSelect"></select>
        <div class="small">Selecting a location will auto-set account and type.</div>
      </div>
      <div>
        <label>Date</label>
        <input id="date" type="date" />
      </div>
    </div>
    <div class="grid2">
      <div>
        <label>Appointment Type ID</label>
        <input id="appt" placeholder="e.g. 50529778" value="" />
      </div>
      <div>
        <label>Calendar</label>
        <select id="calendar"></select>
      </div>
    </div>
    <div class="grid2">
      <div class="full">
        <label>Find by Location (name contains)</label>
        <input id="location" placeholder="e.g. Scottsdale or Tempe" />
        <div class="small">Optional if you pick a calendar below.</div>
      </div>
    </div>
    <div class="row">
      <button id="load">Load calendars</button>
      <button id="check">Fetch availability</button>
      <span id="meta" class="badge" title="Click to toggle debug">waiting…</span>
    </div>
    <div id="mainDiag" class="notice small"></div>
    <div id="typeMeta" class="small"></div>
    <div id="slots" class="slots"></div>
    <pre id="debug" style="display:none"></pre>
  </div>

  <div class="card">
    <h2>Pool availability by location</h2>
    <p>Merge slots across instructors for a single city. Configure each location’s calendars in <code>LOCATION_CONFIG</code>.</p>
    <div class="grid">
      <div>
        <label>Account</label>
        <select id="poolAccount">
          <option value="main">Main</option>
          <option value="parents">Parents</option>
        </select>
      </div>
      <div>
        <label>Location</label>
        <select id="poolLocation"></select>
      </div>
      <div>
        <label>Appointment Type ID</label>
        <input id="poolAppt" placeholder="e.g. 50529778" value="50529778" />
      </div>
    </div>
    <div class="grid2">
      <div>
        <label>Date</label>
        <input id="poolDate" type="date" />
      </div>
      <div>
        <label>Days (1–7)</label>
        <input id="poolDays" type="number" min="1" max="7" value="1" />
      </div>
    </div>
    <div class="row">
      <button id="poolFetch">Fetch pooled availability</button>
      <span id="poolMeta" class="badge" title="Click to toggle debug">waiting…</span>
    </div>
    <div id="poolTypeMeta" class="small"></div>
    <div id="poolDiag" class="notice small"></div>
    <div id="poolSlots" class="slots"></div>
    <pre id="poolDebug" style="display:none"></pre>
  </div>

  <div class="card" id="cal-card">
    <h2 style="margin:0 0 10px">Monthly availability</h2>
    <p class="small">Pick an account and location above, then browse pooled slot counts for the month. Click any day to load live times below.</p>
    <div class="row" style="align-items:center">
      <button id="prevMonth" style="flex:0 0 auto;width:auto;min-width:120px">◀ Prev</button>
      <div id="calLabel" class="badge" style="cursor:default">Month</div>
      <button id="nextMonth" style="flex:0 0 auto;width:auto;min-width:120px">Next ▶</button>
    </div>
    <div id="calGrid" style="display:grid;grid-template-columns:repeat(7,minmax(0,1fr));gap:8px;margin-top:12px"></div>
    <div class="small" id="calNote" style="margin-top:12px"></div>
  </div>
</div>
<script>
const $ = (id) => document.getElementById(id);

const meta = $('meta');
const slots = $('slots');
const dbg = $('debug');
const poolMeta = $('poolMeta');
const poolSlots = $('poolSlots');
const poolDbg = $('poolDebug');
const poolDiag = $('poolDiag');
const typeMeta = $('typeMeta');
const poolTypeMeta = $('poolTypeMeta');
const locationSelect = $('locationSelect');
const poolLocation = $('poolLocation');
const poolAccount = $('poolAccount');
const mainDiag = $('mainDiag');
const mainFetchBtn = $('check');
const poolFetchBtn = $('poolFetch');

const attachBadgeToggle = (badge, output) => {
  if (!badge || !output) return;
  badge.addEventListener('click', () => {
    if (!output.textContent) return;
    output.style.display = output.style.display === 'block' ? 'none' : 'block';
  });
};
attachBadgeToggle(meta, dbg);
attachBadgeToggle(poolMeta, poolDbg);

const setToday = (inputId) => {
  const el = $(inputId);
  if (!el) return;
  const tz = 'America/Phoenix';
  const today = new Date().toLocaleDateString('en-CA', { timeZone: tz });
  el.value = today;
};
setToday('date');
setToday('poolDate');

const LOCATION_GROUPS = {
  main: [
    { value: 'ahwatukee', label: 'Ahwatukee' },
    { value: 'apache junction', label: 'Apache Junction' },
    { value: 'casa grande', label: 'Casa Grande' },
    { value: 'cave creek', label: 'Cave Creek' },
    { value: 'chandler', label: 'Chandler' },
    { value: 'downtown phoenix', label: 'Downtown Phoenix' },
    { value: 'gilbert', label: 'Gilbert' },
    { value: 'mesa', label: 'Mesa' },
    { value: 'queen creek', label: 'Queen Creek' },
    { value: 'san tan valley', label: 'San Tan Valley' },
    { value: 'scottsdale', label: 'Scottsdale' },
    { value: 'tempe', label: 'Tempe' }
  ],
  parents: [
    { value: 'anthem', label: 'Anthem' },
    { value: 'glendale', label: 'Glendale' },
    { value: 'north phoenix', label: 'North Phoenix' },
    { value: 'peoria', label: 'Peoria' },
    { value: 'sun city', label: 'Sun City' },
    { value: 'surprise', label: 'Surprise' }
  ]
};

const LOCATION_LOOKUP = new Map();

const registerLocation = (value, label, account) => {
  const normalized = value.toLowerCase();
  const entry = { value: normalized, label, account };
  LOCATION_LOOKUP.set(normalized, entry);
  const compact = normalized.replace(/\s+/g, '');
  if (compact !== normalized) {
    LOCATION_LOOKUP.set(compact, entry);
  }
};

const populateLocationSelect = (select, includePlaceholder = false) => {
  if (!select) return;
  select.innerHTML = '';
  if (includePlaceholder) {
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select location…';
    select.appendChild(placeholder);
  }
  Object.entries(LOCATION_GROUPS).forEach(([account, locations]) => {
    if (!Array.isArray(locations) || !locations.length) return;
    const group = document.createElement('optgroup');
    group.label = account === 'parents' ? 'Parents account' : 'Main account';
    locations.forEach((loc) => {
      registerLocation(loc.value, loc.label, account);
      const option = document.createElement('option');
      option.value = loc.value;
      option.textContent = loc.label;
      group.appendChild(option);
    });
    select.appendChild(group);
  });
};

populateLocationSelect(locationSelect, true);
populateLocationSelect(poolLocation, false);

const fetchCityType = async (account, location) => {
  const params = new URLSearchParams({ account, location });
  const response = await fetch(`/api/resolve-city?${params.toString()}`);
  if (!response.ok) {
    throw new Error(`City resolver returned ${response.status}`);
  }
  return response.json();
};

const formatTypeMeta = (typeId, label, ok) => {
  if (!typeId) return `No appointment type configured for ${label}.`;
  return ok
    ? `Using appointment type ${typeId} for ${label}.`
    : `Configured type ${typeId} for ${label} is not enabled in Acuity.`;
};

const describeList = (values) => (Array.isArray(values) && values.length ? values.map((v) => String(v)).join(', ') : '—');

const fetchLocationDetails = async (account, location, appointmentTypeId) => {
  const params = new URLSearchParams({ account, location });
  if (appointmentTypeId) params.set('appointmentTypeId', appointmentTypeId);
  const response = await fetch(`/api/resolve-location?${params.toString()}`);
  const json = await response.json().catch(() => ({}));
  return { status: response.status, json };
};

const updateMainDiagnostics = async (accountOverride, locationOverride) => {
  if (!mainDiag) return;
  const account = accountOverride || $('account')?.value || 'main';
  const locationKey = locationOverride || ensureLocationKey();
  const calendarSelect = $('calendar');
  if (!locationKey) {
    mainDiag.textContent = 'Select a location to resolve configured calendars.';
    if (mainFetchBtn) mainFetchBtn.disabled = !calendarSelect?.value;
    return;
  }
  mainDiag.textContent = 'Resolving location calendars…';
  if (mainFetchBtn) mainFetchBtn.disabled = true;
  try {
    const appt = $('appt')?.value.trim();
    const { status, json } = await fetchLocationDetails(account, locationKey, appt);
    if (status !== 200 || !json.ok) {
      mainDiag.textContent = json.error || `Failed to resolve location (HTTP ${status})`;
      return;
    }
    const configuredIds = Array.isArray(json.configuredIds) ? json.configuredIds : [];
    const configuredNames = Array.isArray(json.configuredNames) ? json.configuredNames : [];
    const typeAllowed = Array.isArray(json.typeCalendarIds) ? json.typeCalendarIds : [];
    const resolvedIds = Array.isArray(json.resolvedIds) ? json.resolvedIds : [];
    const disallowed = Array.isArray(json.disallowed) ? json.disallowed : [];
    const unresolved = Array.isArray(json.unresolvedNames) ? json.unresolvedNames : [];

    let html = '';
    html += `<div>Configured IDs (strict): ${describeList(configuredIds)}</div>`;
    if (configuredNames.length) html += `<div>Configured names: ${describeList(configuredNames)}</div>`;
    if (typeAllowed.length) html += `<div>Type-allowed IDs: ${describeList(typeAllowed)}</div>`;
    html += `<div>Final IDs used: ${describeList(resolvedIds)}</div>`;
    if (disallowed.length) html += `<div>Not enabled for this type: ${describeList(disallowed)}</div>`;
    if (unresolved.length) html += `<div>Unresolved names: ${describeList(unresolved)}</div>`;
    mainDiag.innerHTML = html;
    if (mainFetchBtn) {
      const hasExplicitCalendar = Boolean(calendarSelect && calendarSelect.value);
      mainFetchBtn.disabled = !hasExplicitCalendar && resolvedIds.length === 0;
    }
  } catch (error) {
    mainDiag.textContent = error?.message || 'Failed to resolve location calendars.';
  }
};

const applyMainLocation = async (value) => {
  if (!locationSelect) return;
  if (!value) {
    if (typeMeta) typeMeta.textContent = 'Select a location to auto-fill appointment type.';
    if (mainDiag) mainDiag.textContent = 'Select a location to resolve configured calendars.';
    if (mainFetchBtn) mainFetchBtn.disabled = true;
    return;
  }
  const info = LOCATION_LOOKUP.get(value);
  if (!info) {
    if (typeMeta) typeMeta.textContent = 'Unknown location selection.';
    if (mainDiag) mainDiag.textContent = 'Unknown location selection.';
    if (mainFetchBtn) mainFetchBtn.disabled = true;
    return;
  }
  const accountSelect = $('account');
  if (accountSelect) accountSelect.value = info.account;
  const locationInput = $('location');
  if (locationInput) locationInput.value = info.label;
  if (typeMeta) typeMeta.textContent = 'Resolving appointment type…';
  try {
    const data = await fetchCityType(info.account, info.value);
    if (data?.configuredTypeId) {
      $('appt').value = data.configuredTypeId;
      if (typeMeta) typeMeta.textContent = formatTypeMeta(data.configuredTypeId, info.label, data.typeExists !== false);
    } else if (typeMeta) {
      typeMeta.textContent = `No appointment type configured for ${info.label}.`;
    }
  } catch (error) {
    if (typeMeta) typeMeta.textContent = error?.message || 'Failed to resolve appointment type.';
  }
  await updateMainDiagnostics(info.account, info.value);
};

const applyPoolLocation = async (value) => {
  if (!poolLocation) return;
  if (!value) {
    if (poolTypeMeta) poolTypeMeta.textContent = 'Select a location to view pooled availability.';
    if (poolDiag) poolDiag.textContent = 'Select a location to view configured calendars.';
    if (poolFetchBtn) poolFetchBtn.disabled = true;
    return;
  }
  const info = LOCATION_LOOKUP.get(value);
  if (!info) {
    if (poolTypeMeta) poolTypeMeta.textContent = 'Unknown location selection.';
    if (poolDiag) poolDiag.textContent = 'Unknown location selection.';
    if (poolFetchBtn) poolFetchBtn.disabled = true;
    return;
  }
  if (poolAccount) poolAccount.value = info.account;
  if (poolTypeMeta) poolTypeMeta.textContent = 'Resolving appointment type…';
  try {
    const data = await fetchCityType(info.account, info.value);
    if (data?.configuredTypeId) {
      $('poolAppt').value = data.configuredTypeId;
      if (poolTypeMeta) poolTypeMeta.textContent = formatTypeMeta(data.configuredTypeId, info.label, data.typeExists !== false);
    } else if (poolTypeMeta) {
      poolTypeMeta.textContent = `No appointment type configured for ${info.label}.`;
    }
  } catch (error) {
    if (poolTypeMeta) poolTypeMeta.textContent = error?.message || 'Failed to resolve appointment type.';
  }
  updatePoolDiagnostics();
};

const ensureMainType = async () => {
  const typeInput = $('appt');
  if (typeInput && typeInput.value.trim()) return;
  if (locationSelect && locationSelect.value) {
    await applyMainLocation(locationSelect.value);
  }
};

const ensurePoolType = async () => {
  const typeInput = $('poolAppt');
  if (typeInput && typeInput.value.trim()) return;
  if (poolLocation && poolLocation.value) {
    await applyPoolLocation(poolLocation.value);
  }
};

if (locationSelect) {
  locationSelect.addEventListener('change', (event) => {
    applyMainLocation(event.target.value);
  });
  const defaultMain = LOCATION_LOOKUP.has('scottsdale') ? 'scottsdale' : locationSelect.value;
  if (defaultMain) {
    locationSelect.value = defaultMain;
    applyMainLocation(defaultMain);
  }
}

if (poolLocation) {
  poolLocation.addEventListener('change', (event) => {
    applyPoolLocation(event.target.value);
  });
  const defaultPool = LOCATION_LOOKUP.has('scottsdale')
    ? 'scottsdale'
    : (poolLocation.value || (poolLocation.options[0] ? poolLocation.options[0].value : ''));
  if (defaultPool) {
    poolLocation.value = defaultPool;
    applyPoolLocation(defaultPool);
  } else {
    updatePoolDiagnostics();
  }
}
if (!poolLocation) {
  updatePoolDiagnostics();
}

if (poolAccount) {
  poolAccount.addEventListener('change', () => {
    if (poolLocation && poolLocation.value) {
      applyPoolLocation(poolLocation.value);
    } else {
      updatePoolDiagnostics();
    }
  });
}

const updatePoolDiagnostics = async () => {
  if (!poolDiag) return;
  const account = poolAccount?.value || 'main';
  const location = poolLocation?.value;
  if (!location) {
    poolDiag.textContent = 'Select a location to view configured calendars.';
    if (poolFetchBtn) poolFetchBtn.disabled = true;
    return;
  }
  poolDiag.textContent = 'Resolving location calendars…';
  if (poolFetchBtn) poolFetchBtn.disabled = true;
  try {
    const appt = $('poolAppt')?.value.trim();
    const { status, json } = await fetchLocationDetails(account, location, appt);
    if (status !== 200 || !json.ok) {
      poolDiag.textContent = json.error || `Failed to resolve location (HTTP ${status})`;
      return;
    }
    const configuredIds = Array.isArray(json.configuredIds) ? json.configuredIds : [];
    const configuredNames = Array.isArray(json.configuredNames) ? json.configuredNames : [];
    const resolvedIds = Array.isArray(json.resolvedIds) ? json.resolvedIds : [];
    const typeAllowed = Array.isArray(json.typeCalendarIds) ? json.typeCalendarIds : [];
    const disallowed = Array.isArray(json.disallowed) ? json.disallowed : [];
    const unresolved = Array.isArray(json.unresolvedNames) ? json.unresolvedNames : [];

    let html = '';
    html += `<div>Configured IDs (strict): ${describeList(configuredIds)}</div>`;
    if (configuredNames.length) html += `<div>Configured names: ${describeList(configuredNames)}</div>`;
    if (typeAllowed.length) html += `<div>Type-allowed IDs: ${describeList(typeAllowed)}</div>`;
    html += `<div>Final IDs used: ${describeList(resolvedIds)}</div>`;
    if (disallowed.length) html += `<div>Not enabled for this type: ${describeList(disallowed)}</div>`;
    if (unresolved.length) html += `<div>Unresolved names: ${describeList(unresolved)}</div>`;
    poolDiag.innerHTML = html;
    if (poolFetchBtn) poolFetchBtn.disabled = resolvedIds.length === 0;
  } catch (error) {
    poolDiag.textContent = error?.message || 'Failed to resolve location';
  }
};

const fmtLocal = (iso) => {
  try {
    const dt = new Date(iso);
    return dt.toLocaleString([], { hour: 'numeric', minute: '2-digit' });
  } catch (error) {
    return iso;
  }
};

const clearAvailabilitySlots = () => { slots.innerHTML = ''; };
const showAvailabilityError = (msg) => {
  clearAvailabilitySlots();
  const div = document.createElement('div');
  div.className = 'small notice';
  div.textContent = msg;
  slots.appendChild(div);
};

const clearPoolSlots = () => { poolSlots.innerHTML = ''; };
const showPoolError = (msg) => {
  clearPoolSlots();
  const div = document.createElement('div');
  div.className = 'small notice';
  div.textContent = msg;
  poolSlots.appendChild(div);
};

$('load').onclick = async () => {
  meta.textContent = 'Loading calendars…';
  clearAvailabilitySlots();
  dbg.textContent = '';
  dbg.style.display = 'none';
  const account = $('account').value;
  try {
    const response = await fetch(`/api/calendars?account=${encodeURIComponent(account)}`);
    const data = await response.json();
    if (!data.ok) throw new Error(data.error || 'Failed to load calendars');
    const select = $('calendar');
    select.innerHTML = '';
    (data.calendars || []).forEach((calendar) => {
      const option = document.createElement('option');
      option.value = calendar.id;
      option.textContent = `${calendar.name} (#${calendar.id})`;
      select.appendChild(option);
    });
    meta.textContent = `Loaded ${data.calendars?.length || 0} calendars for ${data.account}`;
  } catch (error) {
    meta.textContent = 'Error';
    showAvailabilityError(error.message || String(error));
  }
};

$('check').onclick = async () => {
  meta.textContent = 'Fetching times…';
  clearAvailabilitySlots();
  const date = $('date').value;
  const loc = $('location').value.trim();
  const cal = $('calendar').value;
  await ensureMainType();
  const account = $('account').value;
  const params = new URLSearchParams({ account, appointmentTypeId: $('appt').value.trim(), date });
  if (cal) params.set('calendarID', cal); else if (loc) params.set('location', loc);
  try {
    const response = await fetch(`/api/availability?${params.toString()}`);
    const data = await response.json();
    dbg.textContent = JSON.stringify(data, null, 2);
    dbg.style.display = '';
    if (!data.ok) {
      meta.textContent = 'Error';
      let message = data.error || 'No data returned';
      if (data.acuityStatus === 403) {
        message += '\nTip: enable this appointment type for the selected calendar inside Acuity.';
      }
      return showAvailabilityError(message);
    }
    const count = data.count ?? (Array.isArray(data.times) ? data.times.length : 0);
    meta.textContent = `Found ${count} slots`;
    if (Array.isArray(data.times) && data.times.length) {
      data.times.forEach((time) => {
        const el = document.createElement('div');
        el.className = 'slot';
        const btn = document.createElement('button');
        btn.textContent = 'Copy time';
        btn.onclick = () => navigator.clipboard.writeText(time.time || JSON.stringify(time));
        el.innerHTML = `<b>${fmtLocal(time.time || time.datetime || 'time')}</b><div class="small">slots: ${time.slots ?? '?'}</div>`;
        el.appendChild(btn);
        slots.appendChild(el);
      });
    } else {
      showAvailabilityError('No slots for that date/selection');
    }
  } catch (error) {
    meta.textContent = 'Error';
    showAvailabilityError(error.message || String(error));
  }
};

$('poolFetch').onclick = async () => {
  poolMeta.textContent = 'Fetching pooled availability…';
  clearPoolSlots();
  poolDbg.textContent = '';
  poolDbg.style.display = 'none';
  const date = $('poolDate').value;
  const days = $('poolDays').value || '1';
  await ensurePoolType();
  const account = poolAccount.value;
  const location = poolLocation.value;
  const params = new URLSearchParams({ account, location, appointmentTypeId: $('poolAppt').value.trim(), date, days });
  try {
    const response = await fetch(`/api/location-availability?${params.toString()}`);
    const data = await response.json();
    poolDbg.textContent = JSON.stringify(data, null, 2);
    poolDbg.style.display = '';
    if (!data.ok) {
      poolMeta.textContent = 'Error';
      return showPoolError(data.error || 'No data returned');
    }

    const mergedSlotCount = Array.isArray(data.results)
      ? data.results.reduce((sum, day) => sum + (Array.isArray(day.times) ? day.times.length : 0), 0)
      : 0;
    const totalCapacity = Array.isArray(data.results)
      ? data.results.reduce((sum, day) => sum + (Number(day.totalSlots) || 0), 0)
      : 0;
    const calendarCount = Array.isArray(data.pooledCalendarIds) ? data.pooledCalendarIds.length : 0;
    let metaText = `Merged ${mergedSlotCount} time slot${mergedSlotCount === 1 ? '' : 's'} (${totalCapacity} total seats) across ${calendarCount} calendar${calendarCount === 1 ? '' : 's'}`;
    if (Array.isArray(data.unresolvedCalendars) && data.unresolvedCalendars.length) {
      metaText += ` · unresolved: ${data.unresolvedCalendars.join(', ')}`;
    }
    poolMeta.textContent = metaText;

    if (Array.isArray(data.unresolvedCalendars) && data.unresolvedCalendars.length) {
      const warn = document.createElement('div');
      warn.className = 'notice small';
      warn.textContent = `Unresolved calendars: ${data.unresolvedCalendars.join(', ')}`;
      poolSlots.appendChild(warn);
    }
    if (Array.isArray(data.errors) && data.errors.length) {
      const warn = document.createElement('div');
      warn.className = 'notice small';
      warn.textContent = `Acuity errors: ${data.errors.length} calendars returned issues. See debug for details.`;
      poolSlots.appendChild(warn);
    }

    if (Array.isArray(data.results) && data.results.length) {
      data.results.forEach((day) => {
        const card = document.createElement('div');
        card.className = 'slot';
        card.innerHTML = `<b>${day.date}</b><div class="small">total slots: ${day.totalSlots ?? 0}</div>`;
        const container = document.createElement('div');
        container.className = 'pool-times';
        if (Array.isArray(day.times) && day.times.length) {
          day.times.forEach((time) => {
            const row = document.createElement('div');
            row.className = 'pool-entry';
            const info = document.createElement('div');
            info.className = 'pool-info';
            const sources = Array.isArray(time.sources) && time.sources.length ? time.sources.join(', ') : '—';
            info.innerHTML = `<b>${fmtLocal(time.time || time.datetime || 'time')}</b>` +
              `<div class="small">slots: ${time.slots ?? '?'}</div>` +
              `<div class="sources">Calendars: ${sources}</div>`;
            const btn = document.createElement('button');
            btn.textContent = 'Copy time';
            btn.onclick = () => navigator.clipboard.writeText(time.time || JSON.stringify(time));
            row.appendChild(info);
            row.appendChild(btn);
            container.appendChild(row);
          });
        } else {
          const empty = document.createElement('div');
          empty.className = 'small';
          empty.textContent = 'No slots for this day.';
          container.appendChild(empty);
        }
        card.appendChild(container);
        poolSlots.appendChild(card);
      });
    } else {
      showPoolError('No slots returned for the requested range');
    }
  } catch (error) {
    poolMeta.textContent = 'Error';
    showPoolError(error.message || String(error));
  }
};
</script>
<script>
const calGrid = document.getElementById('calGrid');
const calLabel = document.getElementById('calLabel');
const calNote = document.getElementById('calNote');
const prevMonthBtn = document.getElementById('prevMonth');
const nextMonthBtn = document.getElementById('nextMonth');

const monthTz = 'America/Phoenix';
const todayIso = () => new Date().toLocaleDateString('en-CA', { timeZone: monthTz });

let currentMonthISO = (() => {
  const today = todayIso();
  return today ? `${today.slice(0, 7)}-01` : new Date().toISOString().slice(0, 7) + '-01';
})();

const monthLabel = (ymd) => {
  const dt = new Date(`${ymd}T00:00:00`);
  return dt.toLocaleDateString([], { month: 'long', year: 'numeric' });
};

const shiftMonth = (ymd, delta) => {
  const [year, month] = ymd.split('-').map(Number);
  const base = new Date(Date.UTC(year, month - 1 + delta, 1));
  const y = base.getUTCFullYear();
  const m = String(base.getUTCMonth() + 1).padStart(2, '0');
  return `${y}-${m}-01`;
};

const ensureLocationKey = () => {
  if (locationSelect && locationSelect.value) return locationSelect.value;
  const freeform = $('location');
  return freeform && freeform.value ? freeform.value.trim().toLowerCase() : '';
};

const ensureMonthType = async () => {
  await ensureMainType?.();
  return $('appt').value.trim();
};

const renderMonthGrid = (monthData) => {
  if (!calGrid) return;
  calGrid.innerHTML = '';
  const headers = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  headers.forEach((label) => {
    const cell = document.createElement('div');
    cell.className = 'small';
    cell.style.textAlign = 'center';
    cell.style.opacity = '0.7';
    cell.textContent = label;
    calGrid.appendChild(cell);
  });

  const base = new Date(`${currentMonthISO}T00:00:00`);
  const firstWeekday = base.getDay();
  for (let i = 0; i < firstWeekday; i += 1) {
    const pad = document.createElement('div');
    pad.style.opacity = '0.2';
    pad.style.border = '1px solid var(--edge)';
    pad.style.borderRadius = '10px';
    calGrid.appendChild(pad);
  }

  const totalDays = monthData?.days || 0;
  const counts = monthData?.byDate || {};
  const account = $('account')?.value || 'main';
  const loc = ensureLocationKey();

  for (let day = 1; day <= totalDays; day += 1) {
    const date = `${currentMonthISO.slice(0, 8)}${String(day).padStart(2, '0')}`;
    const count = Number(counts[date] || 0);

    const cell = document.createElement('button');
    cell.style.border = '1px solid var(--edge)';
    cell.style.borderRadius = '12px';
    cell.style.padding = '10px';
    cell.style.background = '#0f172a';
    cell.style.color = 'inherit';
    cell.style.display = 'flex';
    cell.style.flexDirection = 'column';
    cell.style.alignItems = 'center';
    cell.style.gap = '4px';
    cell.innerHTML = `<div style="font-weight:700">${day}</div><div class="small">${count} slot${count === 1 ? '' : 's'}</div>`;
    cell.onclick = async () => {
      calNote.textContent = 'Loading pooled times…';
      await ensureMonthType();
      const appt = $('appt').value.trim();
      if (!appt) {
        calNote.textContent = 'No appointment type configured for this location.';
        return;
      }
      const params = new URLSearchParams({
        account,
        location: loc,
        appointmentTypeId: appt,
        date,
        days: '1'
      });
      try {
        const response = await fetch(`/api/location-availability?${params.toString()}`);
        const data = await response.json();
        if (!data.ok) {
          calNote.textContent = data.error || 'Failed to load daily availability.';
          return;
        }
        const times = Array.isArray(data.results?.[0]?.times) ? data.results[0].times : [];
        calNote.textContent = times.length
          ? `Times for ${date}: ${times
              .map((entry) => fmtLocal(entry.time || entry.datetime || 'time'))
              .join(' · ')}`
          : `No slots for ${date}.`;
      } catch (error) {
        calNote.textContent = error?.message || 'Failed to load daily availability.';
      }
    };

    calGrid.appendChild(cell);
  }
};

const loadMonth = async () => {
  if (!calGrid || !calLabel) return;
  const accountSelect = $('account');
  const account = accountSelect ? accountSelect.value : 'main';
  const locationKey = ensureLocationKey();
  if (!locationKey) {
    calGrid.innerHTML = '<div class="small" style="grid-column:1/-1">Choose a location to view the month.</div>';
    calLabel.textContent = 'Month';
    calNote.textContent = '';
    return;
  }

  calLabel.textContent = monthLabel(currentMonthISO);
  calGrid.innerHTML = '<div class="small" style="grid-column:1/-1">Loading…</div>';
  calNote.textContent = '';

  const params = new URLSearchParams({ account, location: locationKey, date: currentMonthISO });
  try {
    const response = await fetch(`/api/month-availability?${params.toString()}`);
    const data = await response.json();
    if (!data.ok) {
      calGrid.innerHTML = `<div class="small" style="grid-column:1/-1">${data.error || 'Failed to load month availability.'}</div>`;
      calNote.textContent = '';
      return;
    }
    calNote.textContent = `Using appointment type ${data.appointmentTypeId} across ${data.calendarIDs.length} calendar${data.calendarIDs.length === 1 ? '' : 's'}.`;
    renderMonthGrid(data);
  } catch (error) {
    calGrid.innerHTML = `<div class="small" style="grid-column:1/-1">${error?.message || 'Failed to load month availability.'}</div>`;
    calNote.textContent = '';
  }
};

prevMonthBtn?.addEventListener('click', () => {
  currentMonthISO = shiftMonth(currentMonthISO, -1);
  loadMonth();
});

nextMonthBtn?.addEventListener('click', () => {
  currentMonthISO = shiftMonth(currentMonthISO, 1);
  loadMonth();
});

$('account')?.addEventListener('change', () => {
  currentMonthISO = currentMonthISO || `${todayIso().slice(0, 7)}-01`;
  loadMonth();
  updateMainDiagnostics();
});

locationSelect?.addEventListener('change', () => {
  currentMonthISO = currentMonthISO || `${todayIso().slice(0, 7)}-01`;
  loadMonth();
});

$('appt')?.addEventListener('change', () => {
  updateMainDiagnostics();
});

$('poolAppt')?.addEventListener('change', () => {
  updatePoolDiagnostics();
});

$('location')?.addEventListener('blur', () => {
  const value = $('location').value.trim().toLowerCase();
  if (value) {
    updateMainDiagnostics($('account')?.value || 'main', value);
  }
});

$('calendar')?.addEventListener('change', (event) => {
  if (mainFetchBtn) mainFetchBtn.disabled = !event.target.value && (!mainDiag || /Final IDs used: —/.test(mainDiag.textContent));
});

document.addEventListener('DOMContentLoaded', () => {
  loadMonth();
});

loadMonth();
</script>
</body></html>
